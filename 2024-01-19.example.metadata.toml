# Mandatory Keys

title = "An Example Dataset"

owner = "Guido Incognito"
# TODO: Instead of making `contact` an optional key later, do we want to
#       specify that owner always has to be a map with the mandatory
#       keys `name` and `contact`? That would mean one could write the
#       following options.
#
#           owner = {name: "Guido Incognito", contact: "guy@incogni.to"}
#
#           owner.name = "Guido Incognito" 
#           owner.contact = "guy@incogni.to"
#
#           [owner]
#           name = "Guido Incognito"
#           contact = "guy@incogni.to"

access-control = 3
# TODO: Now that we don't put the access level into the filename
#       anymore, do we want to use verbose names here? Like e.g.
#       "published", "public", "internal", "restricted",
#       {"eyes only"|"sealed"|"locked"}.
#       Then we could write:
#
#           access = "published"
#
#       or
#
#           access = "restricted"
#
#       Con: Possibilities for typos. List might be harder to memorize
#            than just integers between 0 and 4.
#       Pro: Less obtuse. Allows for a shorter field name. Open to
#            semantic extensions.
#            (Integer keys would have to be extended linearly, so a new
#            access level we haven't thought about would get the number
#            5, even if it would fall between levels 1 and 2.)
#
#       Also, if `access = "restricted"`, how would the restrictions be
#       specified?

format = "netCDF"
# TODO: Thinking about this, I noticed that the format should actually
#       be defined via the file extensions. So what information would
#       this field contain, that couldn't be obtained by extensions like
#       `.csv`, `.json`, `.nc`?
#       OTH, `.nc` is already a quite cryptic file extension, so making
#       sure that it's netCDF and not some other weird format that has
#       the `.nc` file extension seems like a good idea. Also, one could
#       use this to specify that a `.zip` file contains a "Data Package"
#       or that a folder contains a "Git Repository".
#       I'd also recommend making `format.name` mandatory. Then one
#       would have the option to also specify sources for further
#       information on the format:
#
#         format.name = "Data Package"  
#         format.url = "https://specs.frictionlessdata.io/data-package/"


# Optional Fields

description = """
Just some example data. Actually this file is only used, to act as an
example of what the metadata TOML file looks like.
"""
timeinterval.start = 1970-01-01 00:00:00Z
timeinterval.stop = 2024-12-02 20:24:12+02:00
# begin/end, left/right, alpha/omega, α/ω, Α/Ω ?
timeinterval.resolution = "15 min"


# This is my proposal on how to handle complex cases: allow optional
# tables for each file, specified with a relative path, to override
# metadata items on a per file basis. The path will be interpreted as
# being rooted at the directory, to which the metadata file applies. No
# `..`s allowed in the path.
["foo/bar/file.one"]
owner.name = "Foo Bar"
owner.contact = "foo@bar.foobar"
format.name = "The hilarious foobar format."

# Last but not least: maybe we want to allow people to specify directory
# metadata with a `.hyBit-metadata.toml` file inside the directory? This
# would lead to less clutter and the file can be versioned, if the
# directory contains a Git repository.

# This is my last proposal. Sorry for making this so long again. I tend
# to overengineer when not kept in check.
